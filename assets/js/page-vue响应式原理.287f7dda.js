(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{763:function(e,t,v){"use strict";v.r(t);var r=v(1),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue响应式原理"}},[e._v("#")]),e._v(" "),v("code",[e._v("vue")]),e._v("响应式原理")]),e._v(" "),v("blockquote",[v("p",[e._v("响应式指的是视图层View与Model数据之间“联动关系”，只要任意一方改变另一方也会跟着改变。")])]),e._v(" "),v("h2",{attrs:{id:"vue2响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue2响应式原理"}},[e._v("#")]),e._v(" vue2响应式原理")]),e._v(" "),v("ul",[v("li",[e._v("要做到View与Model的响应式变化，第一步就是需要在二者之间建立联系，"),v("code",[e._v("vue2")]),e._v("中是通过"),v("code",[e._v("Object.defineProperty()")]),v("sup",[e._v("(1)")]),e._v("来实现的...")])]),e._v(" "),v("blockquote",[v("p",[e._v("​\t- "),v("code",[e._v("Javascript")]),e._v("中的"),v("code",[e._v("defineProperty()")]),e._v("是对象"),v("code",[e._v("Object")]),e._v("的一个方法，可以通过此方法对对象的属性进行添加或修改；")]),e._v(" "),v("p",[e._v("​\t- 语法："),v("code",[e._v("Object.defineProperty(object,property,{})")])]),e._v(" "),v("p",[e._v("​\t- 注意事项：只能通过Object调用该方法，而不能通过对象的实例调用该方法")])]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("vue")]),e._v("会遍历"),v("code",[e._v("data")]),e._v("对象中所有"),v("code",[e._v("property")]),e._v("并通过"),v("code",[e._v("Object.defineProperty()")]),e._v("为每一个property设置getter/setter方法，用以对property的读取和修改，")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("vue")]),e._v("会给每一个"),v("code",[e._v("vue")]),e._v("实例建立一个"),v("code",[e._v("watched")]),e._v("实例，这个实例做两件事，\n"),v("ol",[v("li",[e._v("在"),v("code",[e._v("DOM")]),e._v("树渲染时，"),v("code",[e._v("watched")]),e._v("实例会通过"),v("code",[e._v("data")]),e._v("的"),v("code",[e._v("property")]),e._v("的getter方法为对应的property建立依赖；")]),e._v(" "),v("li",[e._v("当修改依赖项时会触发setter方法，watched实例监测到被触发的setter方法，从而使其对应的组件重新渲染；")])])])]),e._v(" "),v("h2",{attrs:{id:"vue3响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3响应式原理"}},[e._v("#")]),e._v(" vue3响应式原理")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("vue3中的响应式时通过JavaScript的Proxy对象来实现的，")]),e._v(" "),v("blockquote",[v("ul",[v("li",[e._v("Proxy对象会创建一个对象的代理，目的是拦截对目标对象的所有“交互”操作；")]),e._v(" "),v("li",[e._v("语法：let proxy=new Proxy(target,handler)\n"),v("ul",[v("li",[e._v("handler——一个通常以函数作为属性的对象，这些属性代表的是在对target操作时代理p的行为")]),e._v(" "),v("li",[e._v("handler对象的默认属性包含set，get")]),e._v(" "),v("li",[e._v("难点：在Proxy对象")])])])])]),e._v(" "),v("ul",[v("li",[e._v("vue3通过Proxy对象给data对象中的property创建一个proxy代理，proxy的handler上面包含"),v("code",[e._v("proxy.set(target,property)")]),e._v("和"),v("code",[e._v("proxy.get(target,property)")]),e._v("方法\n"),v("ul",[v("li",[e._v("get方法中调用一个track方法，目的是检测当前是哪一个effect在运行，并将其与property、target记录在一起，effect方法对当前运行的代码进行包裹，目的是将其记录；")]),e._v(" "),v("li",[e._v("set方法中调用trigger方法，目的是检测哪些effect方法依赖于目标property，并执行这些effect方法")])])]),e._v(" "),v("li",[e._v("这个代理主要做三件事：\n"),v("ol",[v("li",[e._v("在某个property被读取时进行追踪：调用get方法，将运行的代码(effect)、target、property记录在一起")]),e._v(" "),v("li",[e._v("当某个值发生改变时进行检测：调用set方法")]),e._v(" "),v("li",[e._v("重新运行代码来读取原始值：触发trigger方法，")])])])])])])])])])}),[],!1,null,null,null);t.default=_.exports}}]);